
0 Maximum Sum Subarray:-

	1). Brute Force O(NxNxN) (3 Loop(or 2 Loop), subArraySize Loop, Array traverse loop, sum of sub array loop)
	2). Divide & conquer ( Modified Quick Sort, while traversing reverse(for left sub array) & forward(for right sub array))
	3). Kadane's Algo (Assumption: Atleast one positive number, Logic :- sum up elements, record max of all positive sum

1 Find Sum Pair Array:- Use Hash Map, Store difference

2 Sort elements by frequency C++ STL

	- Count Frequency using hash table
	- Pair it & create vector table
	- Sort vector table
	- Rearrange all elements according to its frequency in original list

3 Segregate 0s and 1s in an array:-	use two index

	while left < right
		a) if( A[start] == 0 ), increament start index
		b) else if( A[end] == 1 ), decreament end index
		c) else swap

4 Segregate 0s, 1s and 2s in an array :- 	use three index

	while mid <= right
		a) if( A[mid] == 0 ), swap start & mid, increament start & mid index
		b) else if( A[mid] == 1 ), increament mid index
		c) else if( A[mid] == 2 ), swap end & mid, decreament end index

5 First & Last & Count of Occurence of Element in sorted Array :- Modified Binary Search

6 Find subarray with given sum :- 

	- Keeps Adding elements till total is less than sum
	- If total is greater than sum, start removing element from back untill total become less than given sum
	- Every time check for total = sum 

7 Sort elements by frequency C++ STL:- Use vector of pair & hash map

	- Count Frequency using hash table
	- Pair it & create vector table
	- Sort vector table
	- Rearrange all elements according to its frequency in original list

8 Kth Largest (Or Smallest) Element in Array:- Partition logic of quick sort

9 Find the max in  first increasing and then decreasing array:- Modified Binary Search

	i) If the mid element is greater than both of its adjacent elements, then mid is the maximum.
	ii) If mid element is greater than its next element and smaller than the previous element then max lies on left side of mid
	iii) If mid element is smaller than its next element and greater than the previous element then max lies on right side of mid

10 Find how many times sorted array rotated :- Modified Binary Search ( Use Property of pivoted element (prev & next both are greater than pivot))

11 Find Element in Sorted Rotated Array:- 

	- If A[mid] == Element
	- If A[end] >= A[mid] 
		a). If Element lie in between mid & end, start = mid + 1
		b). else end = mid - 1
	- If A[mid] <= A[start]
		a). IF Element lie in between mid & start, end = mid - 1
		b). else start = mid + 1
		
12 Trapping Rain Water :-
	- Pre-compute highest bar on left and right of every bar in O(n) time. Then use pre-computed values to find the amount of water in every element. 
	- Time complexity of this solution is O(n).




